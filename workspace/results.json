{
  "problem_statement": "This chapter shares similarities with chapter 1, with key differences highlighted in bold.\nMeta employees love two things: building cool products and scaling them up. As a new intern, you just started work on a cool product, but you want to make it even cooler during your internship.\nInitially, your empty product has coolness \n1\n1. Each of the next \n2\n\u00d7\nN\n2\u00d7N days, you'll make a change, multiplying your product's coolness by any positive integer of your choice subject to the following requirements:\nAfter the first \nN\nN days, the coolness can be at most \nA\nA (you're new to the codebase, so you shouldn't scale too quickly).\nAfter all \n2\n\u00d7\nN\n2\u00d7N days, your product should have coolness exactly \nB\nB.\nPlease calculate how many sequences of \n2\n\u00d7\nN\n2\u00d7N changes exist that yield a final product of coolness \nB\nB, while ensuring a coolness of at most \nA\nA after day \nN\nN. As this number can be quite large, print it modulo \n1\n0\n9\n+\n7\n10 \n9\n +7.\nConstraints\n1\n\u2264\nT\n\u2264\n140\n1\u2264T\u2264140\n1\n\u2264\nN\n\u2264\n1\n0\n16\n1\u2264N\u226410 \n16\n \n1\n\u2264\nA\n\u2264\n1\n0\n14\n1\u2264A\u226410 \n14\n \n1\n\u2264\nB\n\u2264\n1\n0\n14\n1\u2264B\u226410 \n14\n \nNote: This chapter allows for much larger input than Chapter 1.\nInput Format\nInput begins with a single integer \nT\nT, the number of test cases. Each case is a single line of three space-separated integers \nN\nN, \nA\nA, and \nB\nB.\nOutput Format\nFor the \ni\ni-th test case, print \"Case #i: \" followed by a single integer, the number of sequences of \n2\n\u00d7\nN\n2\u00d7N nonnegative multipliers satisfying the above requirements, modulo \n1\n0\n9\n+\n7\n10 \n9\n +7.\nSample Explanation\nIn the second test case, there are \n12\n12 sequences which satisfy the requirements of having coolness at most \n10\n10 after day \n2\n2 and exactly \n15\n15 after day \n4\n4. Four of these 12 are:\n[\n5\n,\n1\n,\n3\n,\n1\n]\n[5,1,3,1]\n[\n5\n,\n1\n,\n1\n,\n3\n]\n[5,1,1,3]\n[\n3\n,\n1\n,\n5\n,\n1\n]\n[3,1,5,1]\n[\n3\n,\n1\n,\n1\n,\n5\n]\n[3,1,1,5]\nSample Input\n4\n3 1 7\n2 10 15\n2 1000 21\n50 50000 3628800\nSample Output\nCase #1: 3\nCase #2: 12\nCase #3: 16\nCase #4: 229471373",
  "test_input": "17\n1 1 1\n1 5 3\n2 10 15\n2 5 7\n2 10 10\n1 1 1\n1 100000000000000 100000000000000\n10000000000000000 100000000000000 1\n10000000000000000 100000000000000 100000000000000\n2 1 7\n2 100000000000000 99999999999989\n10000000000000000 100000000000000 99999999999989\n2 100000000000000 720720\n10000000000000000 100000000000000 720720\n10000000000000000 10 100000000000000\n10000000000000000 1 100000000000000\n10000000000000000 100000000000000 1000002200000057\n",
  "test_output": "Case #1: 1\nCase #2: 2\nCase #3: 12\nCase #4: 2\nCase #5: 16\nCase #6: 1\nCase #7: 225\nCase #8: 1\nCase #9: 320312506\nCase #10: 2\nCase #11: 16\nCase #12: 862800007\nCase #13: 89600\nCase #14: 151114340\nCase #15: 899433242\nCase #16: 45271960\nCase #17: 897100007\n",
  "brute_force_code": "MOD = 10**9 + 7\nMAX_EXPONENT = 60\n\nfact = [1] * MAX_EXPONENT\ninv_fact = [1] * MAX_EXPONENT\n\ndef precompute_factorials():\n    for i in range(1, MAX_EXPONENT):\n        fact[i] = (fact[i-1] * i) % MOD\n    inv_fact[MAX_EXPONENT - 1] = pow(fact[MAX_EXPONENT - 1], MOD - 2, MOD)\n    for i in range(MAX_EXPONENT - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\nprecompute_factorials()\n\ndef nCr_large_n(n_val, r_val):\n    if r_val < 0:\n        return 0\n    if r_val == 0:\n        return 1\n    if r_val >= MAX_EXPONENT:\n        return 0\n    \n    n_val_mod = n_val % MOD\n    res = 1\n    for i in range(r_val):\n        res = (res * (n_val_mod + i)) % MOD\n    res = (res * inv_fact[r_val]) % MOD\n    return res\n\ndef solve():\n    N, A, B = map(int, input().split())\n\n    prime_factors_B = []\n    exponents_B = []\n    temp_B = B\n    d = 2\n    while d * d <= temp_B:\n        if temp_B % d == 0:\n            prime_factors_B.append(d)\n            count = 0\n            while temp_B % d == 0:\n                temp_B //= d\n                count += 1\n            exponents_B.append(count)\n        d += 1\n    if temp_B > 1:\n        prime_factors_B.append(temp_B)\n        exponents_B.append(1)\n\n    divisors = [1]\n    for p, e in zip(prime_factors_B, exponents_B):\n        new_divs = []\n        for d_val in divisors:\n            p_power = 1\n            for _ in range(e + 1):\n                new_divs.append(d_val * p_power)\n                p_power *= p\n        divisors = new_divs\n    \n    total_ans = 0\n    for X in divisors:\n        if X > A:\n            continue\n        \n        ways_X = 1\n        ways_B_div_X = 1\n        \n        temp_X_for_factors = X\n        \n        for r in range(len(prime_factors_B)):\n            p = prime_factors_B[r]\n            e_r = exponents_B[r]\n\n            x_r = 0\n            while temp_X_for_factors > 0 and temp_X_for_factors % p == 0:\n                temp_X_for_factors //= p\n                x_r += 1\n            \n            ways_X = (ways_X * nCr_large_n(N, x_r)) % MOD\n            ways_B_div_X = (ways_B_div_X * nCr_large_n(N, e_r - x_r)) % MOD\n        \n        total_ans = (total_ans + ways_X * ways_B_div_X) % MOD\n\n    return total_ans\n\nT = int(input())\nfor i in range(1, T + 1):\n    print(f\"Case #{i}: {solve()}\")",
  "optimal_attempts": [
    {
      "attempt_number": 1,
      "timestamp": 1762542998.6389608,
      "code": "import sys\n\n# Constants for modulo arithmetic and maximum exponent\nMOD = 10**9 + 7\nMAX_EXP = 60 # Maximum exponent for prime factors of B (B <= 10^14, 2^46 is ~7*10^13)\n\n# Precomputed inverse factorials for combinations\ninv_fact = [1] * (MAX_EXP + 1)\n# C_vals[exp] stores C(exp + N - 1, exp) mod MOD for the current N\nC_vals = [1] * (MAX_EXP + 1)\n\ndef precompute_inv_factorials():\n    \"\"\"Precomputes inverse factorials modulo MOD up to MAX_EXP.\"\"\"\n    fact = [1] * (MAX_EXP + 1)\n    for i in range(1, MAX_EXP + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_EXP] = pow(fact[MAX_EXP], MOD - 2, MOD)\n    for i in range(MAX_EXP - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\nprecompute_inv_factorials()\n\ndef calculate_C_term(exp, N_minus_1_mod):\n    \"\"\"\n    Calculates C(exp + N - 1, exp) mod MOD.\n    This is the number of ways to express a prime factor p^exp as a product of N integers.\n    \"\"\"\n    if exp == 0:\n        return 1\n    numerator = 1\n    for j in range(exp):\n        term = (exp + N_minus_1_mod - j + MOD) % MOD\n        numerator = (numerator * term) % MOD\n    return (numerator * inv_fact[exp]) % MOD\n\ndef get_prime_factors(num):\n    \"\"\"Returns a dictionary of prime factors and their exponents for a given number.\"\"\"\n    factors = {}\n    d = 2\n    temp_num = num\n    while d * d <= temp_num:\n        while temp_num % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp_num //= d\n        d += 1\n    if temp_num > 1:\n        factors[temp_num] = factors.get(temp_num, 0) + 1\n    return factors\n\n# Global variables for the DFS to avoid passing them repeatedly\nmemo = {}\nprime_factors_B_list = []\nA_global = 0\n\ndef dfs(idx, current_d_val):\n    \"\"\"\n    Recursively calculates the sum of ways for divisors.\n    idx: current index in prime_factors_B_list\n    current_d_val: product of prime factors processed so far (p_0^e_0 * ... * p_{idx-1}^e_{idx-1})\n    \"\"\"\n    if (idx, current_d_val) in memo:\n        return memo[(idx, current_d_val)]\n\n    if idx == len(prime_factors_B_list):\n        return 1 # Base case: product of empty set of terms is 1\n\n    p, b_exp = prime_factors_B_list[idx]\n    res = 0\n    p_power = 1\n    \n    for e in range(b_exp + 1):\n        # Pruning: if current_d_val * p_power exceeds A_global,\n        if current_d_val > A_global // p_power: \n            break\n        \n        ways_d_prime_factor = C_vals[e]\n        ways_B_over_d_prime_factor = C_vals[b_exp - e]\n        \n        g_val = (ways_d_prime_factor * ways_B_over_d_prime_factor) % MOD\n        \n        res = (res + g_val * dfs(idx + 1, current_d_val * p_power)) % MOD\n        \n        p_power *= p\n    \n    memo[(idx, current_d_val)] = res\n    return res\n\ndef solve():\n    global prime_factors_B_list, A_global, memo, C_vals\n\n    N, A, B = map(int, sys.stdin.readline().split())\n\n    N_minus_1_mod = (N - 1) % MOD\n    A_global = A\n    \n    for exp_val in range(MAX_EXP + 1):\n        C_vals[exp_val] = calculate_C_term(exp_val, N_minus_1_mod)\n\n    prime_factors_B_dict = get_prime_factors(B)\n    prime_factors_B_list = list(prime_factors_B_dict.items())\n    \n    memo.clear() # Clear memoization table for each test case\n    \n    return dfs(0, 1)\n\nT = int(sys.stdin.readline())\nfor i in range(1, T + 1):\n    print(f\"Case #{i}: {solve()}\")",
      "verdict": "Accepted",
      "error_message": null,
      "execution_success": true,
      "output_match": true,
      "output_diff": null
    }
  ],
  "success": true,
  "total_attempts": 1
}