{
  "problem_statement": "This problem shares similarities with chapter 2. Here in chapter 1, the ground cannot be used.\nSolid Snake is back at work scaling Metal Platforms! This time, he is bringing his own ladder.\nSolid Snake needs to inspect \nN\nN platforms, numbered \n1\n1 to \nN\nN. The \ni\ni-th platform is a horizontal line segment from points \n(\ni\n,\nA\ni\n)\n(i,A \ni\n\u200b\n ) to \n(\ni\n+\n1\n,\nA\ni\n)\n(i+1,A \ni\n\u200b\n ), inclusive. Solid Snake starts on platform \n1\n1. He can travel between two platforms with a ladder of height \nh\nh or greater if there exists a vertical line segment of length \nh\nh that intersects both platforms.\nMetal Platforms Inc. has tasked you to write a program, \"Scale AI\", to find the length of the shortest ladder that Solid Snake needs to visit each platform at least once, starting from platform \n1\n1.\nConstraints\n1\n\u2264\nT\n\u2264\n65\n1\u2264T\u226465\n1\n\u2264\nN\n\u2264\n100\n1\u2264N\u2264100\n1\n\u2264\nA\ni\n\u2264\n100\n1\u2264A \ni\n\u200b\n \u2264100\nInput Format\nInput begins with a single integer \nT\nT, the number of test cases. The first line of each case is a single integer \nN\nN. The second line of each case contains \nN\nN space-separated integers \nA\n1\n,\n.\n.\n.\n,\nA\nN\nA \n1\n\u200b\n ,...,A \nN\n\u200b\n .\nOutput Format\nFor the \ni\ni-th test case, print \"Case #i: \" followed by the length of the shortest ladder that Solid Snake needs to visit each platform at least once.\nSample Explanation\nIn the first sample case, there are \nN\n=\n5\nN=5 platforms with heights \nA\n=\n[\n2\n,\n4\n,\n5\n,\n1\n,\n4\n]\nA=[2,4,5,1,4] respectively. To be able to access all the platforms, Solid Snake needs a ladder of at least height \n4\n4, with potential placements shown below.\n\nSample Input\n6\n5\n2 4 5 1 4\n3\n13 10 11\n4\n1 3 3 7\n1\n42\n3\n5 50 42\n7\n4 2 5 6 4 2 1\nSample Output\nCase #1: 4\nCase #2: 3\nCase #3: 4\nCase #4: 0\nCase #5: 45\nCase #6: 3",
  "test_input": "16\n4\n10 20 5 15\n3\n7 7 7\n2\n100 1\n5\n1 2 3 2 1\n1\n1\n2\n1 100\n3\n50 50 50\n5\n1 2 3 4 5\n5\n5 4 3 2 1\n5\n1 100 1 100 1\n7\n10 20 50 100 50 20 10\n7\n100 80 50 1 50 80 100\n10\n1 100 2 3 4 5 6 7 8 9\n10\n10 9 8 7 6 5 4 3 1 100\n100\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n100\n1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100 1 100\n",
  "test_output": "Case #1: 15\nCase #2: 0\nCase #3: 99\nCase #4: 1\nCase #5: 0\nCase #6: 99\nCase #7: 0\nCase #8: 1\nCase #9: 1\nCase #10: 99\nCase #11: 50\nCase #12: 49\nCase #13: 99\nCase #14: 99\nCase #15: 0\nCase #16: 99\n",
  "brute_force_code": "def solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    max_diff = 0\n    for i in range(N - 1):\n        diff = abs(A[i] - A[i+1])\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n\nT = int(input())\nfor i in range(1, T + 1):\n    result = solve()\n    print(f\"Case #{i}: {result}\")",
  "optimal_attempts": [
    {
      "attempt_number": 1,
      "timestamp": 1762623301.083112,
      "code": "def solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    if N == 1:\n        return 0\n\n    max_diff = 0\n    for i in range(N - 1):\n        diff = abs(A[i] - A[i+1])\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n\nT = int(input())\nfor i in range(1, T + 1):\n    result = solve()\n    print(f\"Case #{i}: {result}\")",
      "verdict": "Accepted",
      "error_message": null,
      "execution_success": true,
      "output_match": true,
      "output_diff": null,
      "validation": {
        "quick_check": {
          "passed": true,
          "issues": [
            "Warning: No loop over T test cases detected"
          ]
        },
        "complexity_estimate": {
          "time_complexity": "O(N) + recursion",
          "space_complexity": "O(N) - using arrays/lists",
          "max_loop_depth": 1,
          "has_recursion": true
        },
        "complexity_analysis": {
          "time_complexity": "O(N)",
          "space_complexity": "O(N)",
          "time_complexity_explained": "The `solve()` function iterates through the input list `A` of size `N` once in the `for` loop at lines 4-6. Inside the loop, the absolute difference between consecutive elements is calculated and compared with the current maximum difference. This takes constant time, O(1). Therefore, the overall time complexity of the `solve()` function is O(N). The main part of the program iterates `T` times, calling `solve()` each time. Thus, the total time complexity is O(T*N). Since T is at most 65 and N is at most 100, the overall time complexity is O(65 * 100) = O(6500).",
          "space_complexity_explained": "The `solve()` function stores the input list `A` of size `N`. It also uses a few scalar variables like `N`, `max_diff`, `diff`, and `i`, which take constant space, O(1). Therefore, the space complexity of the `solve()` function is O(N).",
          "extracted_constraints": {
            "N_max": 100,
            "T_max": 65,
            "A_i_max": 100
          },
          "max_operations_estimate": 100000000,
          "operations_per_test": 100,
          "will_pass_time": true,
          "will_pass_space": true,
          "bottlenecks": [],
          "optimizations": [],
          "confidence": 1.0,
          "will_pass": true
        },
        "logic_validation": {
          "is_valid": false,
          "issues": [
            {
              "severity": "critical",
              "category": "logic",
              "description": "The problem states that Solid Snake needs to visit each platform at least once. The provided solution only calculates the maximum difference between adjacent platforms. This is incorrect because the shortest ladder needs to allow travel between *any* two platforms, not just adjacent ones. The solution needs to find the maximum difference between *all* pairs of platforms, not just adjacent ones.",
              "line": 7,
              "suggestion": "The solution should iterate through all possible pairs of platforms (i, j) and find the maximum absolute difference between their heights (A[i] and A[j]). This maximum difference will be the shortest ladder length required."
            }
          ],
          "edge_cases_covered": [
            "N=1"
          ],
          "edge_cases_missing": [],
          "confidence": 0.95,
          "passed": false,
          "suggestions": [
            "The solution should iterate through all possible pairs of platforms (i, j) and find the maximum absolute difference between their heights (A[i] and A[j]). This maximum difference will be the shortest ladder length required."
          ]
        }
      }
    }
  ],
  "success": true,
  "total_attempts": 1
}